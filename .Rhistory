} else {
rnd.dose.mat[i, ] <- td_rtlnorm(
n.sims,
log(mn.val),
f.dose.df$SD[i],
a = f.dose.df$Low_Limit[i],
b = f.dose.df$Up_Limit[i]
)
}
} else {
# Normal distribution (lognormal is above)
if (f.dose.df$SD[i] == 0) {
rnd.dose.mat[i, ] <- rep(f.dose.df$Mean[i], n.sims)
} else {
# Sample value at random
rnd.dose.mat[i, ] <-
rtnorm_TruncatedDistributions(
n.sims,
f.dose.df$Mean[i],
abs(f.dose.df$SD[i]), # ensure SD is never negative
a = f.dose.df$Low_Limit[i],
b = f.dose.df$Up_Limit[i]
)
}
}
}
i
f.dose.df$Distribution[i]
is.na(f.dose.df$Distribution[i])
f.dose.df
if(is.na(f.dose.df$Distribution[i])) {
f.dose.df$Distribution[i] <- "normal"
}
# Randomly generate doses based on mean, SD, limits and distribution type
if (f.dose.df$Distribution[i] == "lognormal") {
# If mean < 0 change mean to minimum limit (can't have zero or negative on log scale)
mn.val <- ifelse(f.dose.df$Mean[i] <= 0,
f.dose.df$Low_Limit[i],
f.dose.df$Mean[i]
)
# If SD is zero adjust to a very small number
if (f.dose.df$SD[i] == 0) {
rnd.dose.mat[i, ] <- rep(mn.val, n.sims)
} else {
rnd.dose.mat[i, ] <- td_rtlnorm(
n.sims,
log(mn.val),
f.dose.df$SD[i],
a = f.dose.df$Low_Limit[i],
b = f.dose.df$Up_Limit[i]
)
}
} else {
# Normal distribution (lognormal is above)
if (f.dose.df$SD[i] == 0) {
rnd.dose.mat[i, ] <- rep(f.dose.df$Mean[i], n.sims)
} else {
# Sample value at random
rnd.dose.mat[i, ] <-
rtnorm_TruncatedDistributions(
n.sims,
f.dose.df$Mean[i],
abs(f.dose.df$SD[i]), # ensure SD is never negative
a = f.dose.df$Low_Limit[i],
b = f.dose.df$Up_Limit[i]
)
}
}
for (i in 1:n.dose) {
if(is.na(f.dose.df$Distribution[i])) {
f.dose.df$Distribution[i] <- "normal"
f.dose.df$SD[i] <- 0
}
# Randomly generate doses based on mean, SD, limits and distribution type
if (f.dose.df$Distribution[i] == "lognormal") {
# If mean < 0 change mean to minimum limit (can't have zero or negative on log scale)
mn.val <- ifelse(f.dose.df$Mean[i] <= 0,
f.dose.df$Low_Limit[i],
f.dose.df$Mean[i]
)
# If SD is zero adjust to a very small number
if (f.dose.df$SD[i] == 0) {
rnd.dose.mat[i, ] <- rep(mn.val, n.sims)
} else {
rnd.dose.mat[i, ] <- td_rtlnorm(
n.sims,
log(mn.val),
f.dose.df$SD[i],
a = f.dose.df$Low_Limit[i],
b = f.dose.df$Up_Limit[i]
)
}
} else {
# Normal distribution (lognormal is above)
if (f.dose.df$SD[i] == 0) {
rnd.dose.mat[i, ] <- rep(f.dose.df$Mean[i], n.sims)
} else {
# Sample value at random
rnd.dose.mat[i, ] <-
rtnorm_TruncatedDistributions(
n.sims,
f.dose.df$Mean[i],
abs(f.dose.df$SD[i]), # ensure SD is never negative
a = f.dose.df$Low_Limit[i],
b = f.dose.df$Up_Limit[i]
)
}
}
}
is.na(f.dose.df$Distribution[i])
f.dose.df$SD
if(is.na(f.dose.df$Distribution[i])) {
f.dose.df$Distribution[i] <- "normal"
}
if(is.na(f.dose.df$SD[i])) {
f.dose.df$SD[i] <- 0
}
for (i in 1:n.dose) {
if(is.na(f.dose.df$Distribution[i])) {
f.dose.df$Distribution[i] <- "normal"
}
if(is.na(f.dose.df$SD[i])) {
f.dose.df$SD[i] <- 0
}
# Randomly generate doses based on mean, SD, limits and distribution type
if (f.dose.df$Distribution[i] == "lognormal") {
# If mean < 0 change mean to minimum limit (can't have zero or negative on log scale)
mn.val <- ifelse(f.dose.df$Mean[i] <= 0,
f.dose.df$Low_Limit[i],
f.dose.df$Mean[i]
)
# If SD is zero adjust to a very small number
if (f.dose.df$SD[i] == 0) {
rnd.dose.mat[i, ] <- rep(mn.val, n.sims)
} else {
rnd.dose.mat[i, ] <- td_rtlnorm(
n.sims,
log(mn.val),
f.dose.df$SD[i],
a = f.dose.df$Low_Limit[i],
b = f.dose.df$Up_Limit[i]
)
}
} else {
# Normal distribution (lognormal is above)
if (f.dose.df$SD[i] == 0) {
rnd.dose.mat[i, ] <- rep(f.dose.df$Mean[i], n.sims)
} else {
# Sample value at random
rnd.dose.mat[i, ] <-
rtnorm_TruncatedDistributions(
n.sims,
f.dose.df$Mean[i],
abs(f.dose.df$SD[i]), # ensure SD is never negative
a = f.dose.df$Low_Limit[i],
b = f.dose.df$Up_Limit[i]
)
}
}
}
# Combine multiple stressors across rows into a single dose vector
# multiple stressors must be proportions (ie, conditional mortalities)
rnd.dose <- 1 - apply(rnd.dose.mat, 2, function(x) {
prod(1 - x)
})
rnd.dose <- ifelse(rnd.dose < min(f.stressor.df[, 1], na.rm = T),
min(f.stressor.df[, 1], na.rm = T),
rnd.dose
)
rnd.dose <- ifelse(rnd.dose > max(f.stressor.df[, 1], na.rm = T),
max(f.stressor.df[, 1], na.rm = T),
rnd.dose
)
# Change rnd.dose to log values if stress-response relation is logarithmic
if (f.main.df$Stress_Scale == "log") {
x.dose <- log(rnd.dose)
} else {
x.dose <- rnd.dose
}
# calculate system.capacity vector (x.dose is a vector)
sys.capacity <- tbeta_rnd(
mn_est = f.mean.resp.list[[1]](x.dose),
sd_est = f.mean.resp.list[[2]](x.dose),
low.limit = f.mean.resp.list[[3]](x.dose),
up.limit = f.mean.resp.list[[4]](x.dose)
)
#----------------------------------------------------
# Build and Tests
#----------------------------------------------------
library(usethis)
library(testthat)
library(rhub)
library(devtools)
library(usethis)
library(qpdf)
library(kableExtra)
# Loading unfinished package to memory...
rm(list = ls())
devtools::load_all()
devtools::document()
rm(list = ls())
devtools::load_all()
devtools::document()
rm(list = ls())
devtools::load_all()
devtools::document()
remove.packages("JoeModelCE")
remove.packages("JoeModelCE")
remove.packages("JoeModelCE")
remove.packages("JoeModelCE")
# Loading unfinished package to memory...
rm(list = ls())
devtools::load_all()
devtools::document()
devtools::test()  # Run tests
remove.packages("JoeModelCE")
remove.packages("JoeModelCE")
install.packages(getwd(), repos = NULL, type = "source")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
# Load the JoeModelCE package.
library(JoeModelCE)
filename_lc <- system.file("extdata", "life_cycles.csv", package = "JoeModelCE")
life_cycles <- read.csv(filename_lc)
print(life_cycles)
# Setup objects for population model
pop_mod_setup <- pop_model_setup(life_cycles = life_cycles)
pop_mod_setup
# Build matrix elements for population model
pop_mod_mat <- pop_model_matrix_elements(pop_mod_setup = pop_mod_setup)
names(pop_mod_mat)
print(pop_mod_mat$projection_matrix)
# Preview density-independent transition projection_matrix
A <- pop_mod_mat$projection_matrix
# Assign nicknames for each stage
snames <- c("egg_yoy", "juv", "subadult", "adult")
rownames(A) <- colnames(A) <- snames
# Simple density-independent lambda estimate
popbio::lambda(A)
# Simple Eigen analysis
popbio::eigen.analysis(A)$elasticities
# Set the K.adj (K adjustment prior to pop model run)
life_histories <- pop_mod_mat$life_histories
# Mathematical expression of the transition matrix
life_stages_symbolic <- pop_mod_mat$life_stages_symbolic
# Mathematical expression of the density matrix
density_stage_symbolic <- pop_mod_mat$density_stage_symbolic
life_histories
life_stages_symbolic
density_stage_symbolic
M.mx = life_stages_symbolic
D.mx = density_stage_symbolic
H.mx = NULL
dat = life_histories
K = life_histories$Ka
Nyears = 100
p.cat = 0
CE_df = NULL
# Adjust K to give correct mean after stochasticity
if (is.null(dat$K.adj)) {
dat$K.adj <- 1
}
dat$K.adj
Ka <- K * dat$K.adj
Ka
K
is.null(D.mx)
# Set D = 1 if no density_depenence
if (is.null(D.mx)) {
D <- 1
}
# if no harm set H to 1
if (is.null(H.mx)) {
H <- rep(1, Nyears)
} else if (is.matrix(H.mx)) {
H <- replicate(Nyears, H.mx, simplify = F)
} else {
H <- H.mx
}
H
# Catastrophes
Catastrophe <- sample(
c(1, 0),
Nyears,
replace = TRUE,
prob = c(p.cat / dat$gen.time, 1 - p.cat / dat$gen.time)
)
Catastrophe
# effect on catastrophe on pop size (percent reduction) - scaled Beta dist'n fit from Reed et al. (2003)
e.cat <- sapply(Catastrophe, function(x) {
ifelse(x == 0, NA, stats::rbeta(1, shape1 = 0.762, shape2 = 1.5) * (1 - .5) + .5)
})
e.cat
# Deterministic projection matrix
pmx.det <- pmx_eval(M.mx, c(dat, dat$S, dat$nYrs, dat$mat))
pmx.det
SS <- popbio::stable.stage(pmx_eval(M.mx, c(dat, dat$S, dat$nYrs, dat$mat)))
SS
# evaluate whether we are quantifying the initial carrying capacities correctly
k_stage <- SS / SS[dat$Nstage] * Ka
k_stage
# MJB added line - Nstage was floating in global memory from KW code
Nstage <- dat$Nstage
Nstage
names(k_stage) <- paste("K", 1:Nstage, sep = "")
dat$K <- k_stage
dat$Ke <- E_est(N = dat$K[-1], dat = c(dat, dat$mat, dat$S))
dat$K0 <- dat$Ke * dat$S["sE"]
# Apply the harm matrix to K or S (if needed)
alevin_stage <- 2
all_juv <- 3:5
fry_stages <- 3
fry_parr_stages <- 3:4
# 3 is used as eggs, yoy, and age-0 are not ever mature
parr_stages <- 4
# 3 is used as eggs, yoy, and age-0 are not ever mature
juv_stages <- 1:(3 + max(which(dat$mat == 0)))
adult_stages <- (3 + max(which(dat$mat > 0)))
subadult_stages <- adult_stages - 1
# Apply CE stressors to population parameters
# if not null
if (!(is.null(CE_df))) {
dat <- pop_model_ce_apply(
CE_df = CE_df,
dat = dat,
alevin_stage = alevin_stage,
all_juv = all_juv,
fry_stages = fry_stages,
fry_parr_stages = fry_parr_stages,
parr_stages = parr_stages,
subadult_stages = subadult_stages,
adult_stages = adult_stages)
}
dat
# Fecundity
ft <- lapply(1:(Nyears + 1), function(x) {
f_temp <- f_rand(dat$eps, dat$eps_sd, rho = dat$egg_rho)
f_temp <- ifelse(is.na(f_temp), dat$eps, f_temp)
names(f_temp) <- "eps"
return(f_temp)
})
ft
# Survival
suppressWarnings({
st <- lapply(1:(Nyears + 1), function(x) {
s_temp <- s_rand(dat$S, dat$M.cv, rho = dat$M.rho)
s_temp <- ifelse(is.na(s_temp), 0, s_temp)
s_temp
})
})
st
new_dat <- dat
new_dat[["eps"]] <- NULL
# Population matrix
M.list <- lapply(1:(Nyears + 1), function(x) {
pmx_eval(M.mx, c(new_dat, st[[x]], ft[[x]], new_dat$nYrs, new_dat$mat))
})
M.list
# Initial population structure
N <- sum(new_dat$K) * popbio::stable.stage(M.list[[1]])
N
# number of Egg produced
Na <- Nb_est(N[-1], new_dat$mat)
E <-
E_est(
N = N[-1],
dat = c(new_dat, ft[[1]], st[[1]], new_dat$nYrs, new_dat$mat)
)
# initialize output vectors
Nvec <- rep(NA, Nyears + 1)
# Adult pop vector
Nvec[1] <- Na
# age-specific annual population size
Ns <- list(N)
# population growth rate
lambdas <- rep(NA, Nyears)
# loop through years
for (t in 1:Nyears) {
# Density Dependence
# Survivial
if (is.null(D.mx) == FALSE) {
# create vector os density dependence effects
d.vec <-
d.vec.f(
df = new_dat,
N = c(E, E * st[[t + 1]]["sE"], N),
Ks = c(new_dat$Ke, new_dat$K0, new_dat$K)
)
# check if any survival rates > 1
s.test <- d.vec * st[[t + 1]] # survival rate after DD effects
# MJB added to deal with NA bug
s.test <- ifelse(is.na(s.test), 0, s.test)
if (any(s.test > 1)) {
# any s.test > 1?
s.err <- which(s.test > 1) # ID which is > 1
d.vec[s.err] <-
1 / st[[t + 1]][s.err] # set density depenence effect ot 1/surivval - give s = 1 after DD effects
}
# create density dependence effects matrix
D <- pmx_eval(D.mx, as.list(d.vec))
}
# Population
# Projection matrix
A <- M.list[[t + 1]] * D * H[[t]]
# project the population 1 year ahead.
if (Catastrophe[t] == 1) {
N <- N * (1 - e.cat[t])
} else {
N <- as.vector(A %*% N)
}
# Number of adults
Na <- Nb_est(N[-1], new_dat$mat)
# Number of Juveniles
Nj <- sum(N * c(1, 1 - new_dat$mat))
# number of Egg produced
E <- E_est(N = N[-1], c(new_dat, st[[t + 1]], ft[[t + 1]], new_dat$mat))
# Number of mature fish in pop
Nvec[t + 1] <- Na
Ns[t + 1] <- list(N)
# pop growth rate
lambdas[t] <- Nvec[t + 1] / Nvec[t]
}
lambdas
# Build return object from function
ret_obj <- list(
"pop" = as.data.frame(list(year = 0:Nyears, N = Nvec)),
"N" = do.call(rbind, Ns),
"lambdas" = lambdas,
"vars" = list("ft" = do.call(rbind, ft), "st" = do.call(rbind, st)),
"Cat." = as.data.frame(list("Cat." = Catastrophe, "e.cat" = e.cat))
)
ret_obj
# Run simple population projection - project forward through time
baseline <-
Projection_DD(
M.mx = life_stages_symbolic,
# projection matrix expression
D.mx = density_stage_symbolic,
# density-dependence matrix
H.mx = NULL,
dat = life_histories,
# life history data
K = life_histories$Ka,
# initial pop size as stage-structure vector
Nyears = 100,
# years to run simulation
p.cat = 0,      # Probability of catastrophe
CE_df = NULL
)
names(baseline)
# Time series of the population
plot(baseline$pop, type = 'l')
# Time series of lambda values
plot(baseline$lambdas, type = 'l', ylab = "lambda", xlab = "year")
# Very simple CE data frame of one watershed
# and two stressors (My Stressor1, My Stressor2)
CE_df1 <- data.frame(HUC = 123,
Stressor = "My Stressor1",
dose = 123,      # Stressor magnitude
sys.cap = 0.82,  # Effect of vital rate (dose:response)
life_stage = "fry_parr",
parameter = "capacity",
Stressor_cat = "My Stressor1")
# Second stressor - fake data
CE_df2 <- data.frame(HUC = 123,
Stressor = "My Stressor2",
dose = 123,
sys.cap = 0.95,
life_stage = "all_juv",
parameter = "survival",
Stressor_cat = "My Stressor2")
# Stressors dataframe
CE_df <- rbind(CE_df1, CE_df2)
CE_df
CE_df = CE_df
CE_df
CE_cap
dat$Ke
dat$K0
trow$sys.cap[trow$life_stage == "alevin"]
trow
CE_cap
CE_df$parameter == "capacity",
CE_df
CE_df
CE_cap <- CE_df[CE_df$parameter == "capacity", ]
CE_cap
CE_cap$sys.cap <- CE_cap$sys.cap *5
# Multiply effects additively for cc
trow <- CE_cap[i, ]
i = 1
# Multiply effects additively for cc
trow <- CE_cap[i, ]
trow
if(is.na(trow$sys.cap)) {
# Skip is missing data
next
}
# Check that life stage is valid
valid_stage <- c("egg", "alevin", "all_juv", "fry", "parr", "fry_parr", "juv", "adult", "sub_adult", "all")
valid_stage
if (!(trow$life_stage %in% valid_stage)) {
stop("Invalid life stage for cumulative effects stressor linked to survivorship. Valid survivorship life stages are: ", paste(valid_stage, collapse = ", "))
}
trow$life_stage
dat$K[fry_parr_stages - 2] * trow$sys.cap[trow$life_stage == "fry_parr"]
dat$K
dat$K[fry_parr_stages - 2]
] <- dat$K[fry_parr_stages - 2] * trow$sys.cap[trow$life_stage == "fry_parr"]
dat$K[fry_parr_stages - 2] * trow$sys.cap[trow$life_stage == "fry_parr"]
